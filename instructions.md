# RecipeBuddy Project Documentation

## Project Overview

RecipeBuddy is an iOS application designed to help users discover, organize, and save recipes with the help of AI. The app offers a freemium model:
- Free Tier: Users can search for basic recipes and organize them into folders.
- Premium Subscription: Provides curated, creative, and advanced recipes tailored to users' preferences, along with additional features.

RecipeBuddy combines the simplicity of a recipe search engine with the appeal of a Pinterest-like interface, leveraging AI to generate personalized results.

## Technologies Used

- Platform: iOS (Swift, SwiftUI)
- Backend: Firebase or Supabase for user accounts, data storage, and analytics
- AI Integration: OpenAI API for recipe generation
- Payment Gateway: Apple Pay for in-app subscriptions
- Analytics: Firebase Analytics for tracking user engagement

## Core Functionalities

### 1. AI Recipe Search

**Description**: Users can search for recipes by name or ingredients and receive clear, step-by-step recipes generated by AI.

**User Story**: As a user, I want to search for a recipe using keywords or ingredients and get an accurate, easy-to-follow recipe.

**Functional Requirements**:

*Search Bar*:
- Provide an input field for recipe queries
- Support keyword and ingredient-based searches

*AI Integration*:
- Utilize OpenAI API to generate recipes based on user queries
- Ensure AI-generated recipes include ingredients, quantities, and step-by-step instructions

*Recipe Output*:
- Display results in a clean, readable format
- Include an image of the dish (if available)
- Options to print, save, or share the recipe

**Non-Functional Requirements**:

*Performance*:
- AI-generated recipes should load within 3 seconds

*Usability*:
- Intuitive search functionality with suggestions and auto-complete

### 2. Recipe Organization

**Description**: Users can save recipes into custom folders to keep their collection organized.

**User Story**: As a user, I want to save recipes into folders so I can easily find them later.

**Functional Requirements**:

*Save Functionality*:
- Button to save a recipe to a folder

*Folder Management*:
- Create, rename, and delete custom folders
- Drag and drop recipes between folders

*Folder View*:
- Browse saved recipes within folders
- Search within saved recipes

**Non-Functional Requirements**:

*Synchronization*:
- Saved recipes and folders sync across devices for logged-in users

*Scalability*:
- Efficiently handle a large number of folders and recipes

### 3. Premium Subscription Features

**Description**: Unlocks access to curated, creative recipes and additional functionalities.

**User Story**: As a user, I want to subscribe to access curated recipes and advanced features to enhance my cooking experience.

**Functional Requirements**:

*Curated Recipes*:
- Access to exclusive, high-quality recipes
- Recipes tailored to user preferences (dietary restrictions, cuisine types)

*Advanced Search*:
- Filter by dietary needs, difficulty level, preparation time, etc.

*Unlimited Saving*:
- No limit on the number of recipes and folders saved

*Exclusive Content*:
- Seasonal collections, cooking tips, and video tutorials

**Non-Functional Requirements**:

*Security*:
- Secure handling of payment information and subscription data

*Compliance*:
- Adhere to Apple's guidelines for in-app purchases

### 4. Freemium Monetization Model

**Description**: Offers basic features for free, with incentives to upgrade for premium content.

**User Story**: As a free user, I want to explore the app's features to decide if upgrading to premium is worthwhile.

**Functional Requirements**:

*Free Tier*:
- Access to basic AI-generated recipes
- Ability to save a limited number of recipes (e.g., up to 20)

*Premium Tier*:
- Access to all premium features as described above
- Priority customer support

**Non-Functional Requirements**:

*User Engagement*:
- Regular prompts highlighting premium benefits

*Retention Strategies*:
- Offer trials or discounts to free users

### 5. Printing and Sharing Recipes

**Description**: Users can print or share recipes directly from the app.

**User Story**: As a user, I want to print or share recipes for convenient access during cooking or to share with friends.

**Functional Requirements**:

*Print Integration*:
- Utilize iOS's native print functionality

*Sharing Options*:
- Share via email, messaging apps, or social media
- Generate shareable links or PDF versions

**Non-Functional Requirements**:

*Ease of Use*:
- Accessible sharing options within the recipe view

*Compatibility*:
- Ensure shared content displays correctly across platforms

## Technical Requirements

### Platform

- iOS Version Support: iOS 14 and above
- Development Language: Swift, utilizing SwiftUI for the user interface

### Backend

*User Authentication*:
- Email/password, Apple ID, and third-party logins (e.g., Google, Facebook)

*Data Storage*:
- Secure storage of user data, recipes, and folders

*Real-time Database*:
- For syncing saved recipes and folders across devices

### AI Integration

*API Utilization*:
- Use the OpenAI API for recipe generation

*Error Handling*:
- Implement retries and fallbacks for API failures

*Scalability*:
- Handle multiple concurrent requests efficiently

### In-App Purchases

*Payment Processing*:
- Use StoreKit for handling subscriptions

*Subscription Management*:
- Support upgrades, downgrades, cancellations, and renewals

*Security*:
- Validate receipts and secure transaction data

### Analytics

*User Engagement Metrics*:
- Track feature usage, session duration, and retention rates

*Crash Reporting*:
- Integrate tools like Firebase Crashlytics

*Privacy Compliance*:
- Obtain user consent where necessary and provide opt-out options

## API Specifications

### Recipe Generation API (Using OpenAI API)

#### Overview

The Recipe Generation API leverages the OpenAI API to generate recipes based on user inputs. When a user searches for a recipe, the app sends a request to the OpenAI API with a carefully crafted prompt. The API responds with a recipe that includes ingredients, quantities, and step-by-step instructions.

#### API Integration Workflow

1. User Input: The user enters a recipe name or ingredients in the search bar
2. Prompt Construction: The app constructs a prompt based on the user's input
3. API Request: The app sends a request to the OpenAI API with the constructed prompt
4. API Response: The OpenAI API returns a recipe in text or JSON format
5. Response Parsing: The app parses the response and displays it in a structured format

#### OpenAI API Usage Details

- API Endpoint: https://api.openai.com/v1/chat/completions
- Method: POST
- Headers:
  - Authorization: Bearer YOUR_OPENAI_API_KEY
  - Content-Type: application/json
- Model: gpt-3.5-turbo (or gpt-4 for premium features)
- Temperature: Adjust between 0.7 to 0.9 for creativity
- Max Tokens: Set appropriate limit to control the response length (e.g., max_tokens: 500)

#### Sample API Request

```swift
import Foundation

func generateRecipe(query: String, completion: @escaping (Result<String, Error>) -> Void) {
    let apiKey = "YOUR_OPENAI_API_KEY"
    let endpoint = URL(string: "https://api.openai.com/v1/chat/completions")!

    let prompt = """
    You are a professional chef. Generate a detailed recipe for "\(query)". Include a list of ingredients with quantities and step-by-step cooking instructions. Format the response in JSON with 'title', 'ingredients', and 'instructions' fields.
    """

    let requestBody: [String: Any] = [
        "model": "gpt-3.5-turbo",
        "messages": [
            ["role": "system", "content": "You are a helpful assistant that generates cooking recipes."],
            ["role": "user", "content": prompt]
        ],
        "temperature": 0.7,
        "max_tokens": 500
    ]

    var request = URLRequest(url: endpoint)
    request.httpMethod = "POST"
    request.addValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
    request.addValue("application/json", forHTTPHeaderField: "Content-Type")

    do {
        let httpBody = try JSONSerialization.data(withJSONObject: requestBody, options: [])
        request.httpBody = httpBody
    } catch {
        completion(.failure(error))
        return
    }

    let task = URLSession.shared.dataTask(with: request) { data, response, error in
        if let error = error {
            completion(.failure(error))
            return
        }

        guard let data = data else {
            completion(.failure(NSError(domain: "No data returned", code: 0, userInfo: nil)))
            return
        }

        do {
            // Parse the API response
            if let jsonResponse = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any],
               let choices = jsonResponse["choices"] as? [[String: Any]],
               let message = choices.first?["message"] as? [String: Any],
               let content = message["content"] as? String {
                completion(.success(content))
            } else {
                completion(.failure(NSError(domain: "Invalid response format", code: 0, userInfo: nil)))
            }
        } catch {
            completion(.failure(error))
        }
    }

    task.resume()
}
```

#### Sample Prompt and Response

**Prompt Sent to OpenAI API**:

```
You are a professional chef. Generate a detailed recipe for "Classic Lasagna". Include a list of ingredients with quantities and step-by-step cooking instructions. Format the response in JSON with 'title', 'ingredients', and 'instructions' fields.
```

**Sample API Response**:

```json
{
  "title": "Classic Lasagna",
  "ingredients": [
    "12 lasagna noodles",
    "1 pound ground beef",
    "1 jar (24 oz) marinara sauce",
    "15 oz ricotta cheese",
    "2 cups shredded mozzarella cheese",
    "1/2 cup grated Parmesan cheese",
    "1 egg",
    "2 cloves garlic, minced",
    "1 teaspoon dried oregano",
    "Salt and pepper to taste"
  ],
  "instructions": [
    "Preheat the oven to 375°F (190°C).",
    "Cook the lasagna noodles according to package instructions. Drain and set aside.",
    "In a large skillet, brown the ground beef over medium heat. Add minced garlic and cook for 1 minute.",
    "Stir in the marinara sauce and dried oregano. Simmer for 10 minutes. Season with salt and pepper.",
    "In a bowl, mix ricotta cheese, egg, and half of the Parmesan cheese until well combined.",
    "Spread a thin layer of meat sauce on the bottom of a 9x13-inch baking dish.",
    "Place 4 lasagna noodles over the sauce.",
    "Spread half of the ricotta mixture over the noodles.",
    "Sprinkle 1 cup of mozzarella cheese over the ricotta layer.",
    "Repeat the layers: sauce, noodles, ricotta mixture, mozzarella cheese.",
    "Top with remaining meat sauce and sprinkle with remaining mozzarella and Parmesan cheese.",
    "Cover with aluminum foil and bake for 25 minutes.",
    "Remove foil and bake for an additional 25 minutes, or until the cheese is bubbly and golden brown.",
    "Let the lasagna rest for 15 minutes before serving."
  ]
}
```

#### Parsing the Response

```swift
func parseRecipe(from content: String) -> Recipe? {
    guard let data = content.data(using: .utf8) else { return nil }

    do {
        let recipe = try JSONDecoder().decode(Recipe.self, from: data)
        return recipe
    } catch {
        print("Error parsing recipe: \(error)")
        return nil
    }
}
```

#### Updated Recipe Data Model

```swift
// Recipe.swift
struct Recipe: Identifiable, Codable {
    let id: UUID = UUID()
    let title: String
    let ingredients: [String]
    let instructions: [String]
    let imageUrl: URL? = nil
    let isPremium: Bool = false
}
```

#### Handling Edge Cases

- Invalid JSON Format: If the AI returns text that isn't valid JSON, implement a fallback to extract the recipe using text parsing or request a regeneration
- API Rate Limits: Monitor and handle rate limits as per OpenAI's usage policies
- Error Responses: Implement robust error handling for API failures, including retries and user notifications

#### Security Considerations

- API Key Management: Store your OpenAI API key securely. Do not hard-code it in the app
- Compliance: Ensure compliance with OpenAI's terms of service, especially regarding data handling and user privacy

#### Testing the Integration

- Unit Tests: Write tests to mock API responses and validate parsing logic
- Integration Tests: Test the full flow from user input to displaying the generated recipe
- Error Handling Tests: Simulate API failures and ensure the app responds gracefully

#### Logging and Monitoring

- Analytics: Log API usage patterns to optimize prompt engineering
- Monitoring: Set up alerts for API errors or unusual activity

## File Structure

```
RecipeBuddy/
├── README.md
├── App/
│   ├── Views/
│   │   ├── RecipeSearchView.swift
│   │   ├── RecipeDetailView.swift
│   │   ├── FolderListView.swift
│   │   ├── FolderDetailView.swift
│   │   ├── PremiumFeaturesView.swift
│   │   ├── SubscriptionView.swift
│   │   └── SettingsView.swift
│   ├── ViewModels/
│   │   ├── RecipeSearchViewModel.swift
│   │   ├── RecipeDetailViewModel.swift
│   │   ├── FolderViewModel.swift
│   │   ├── PremiumFeaturesViewModel.swift
│   │   ├── SubscriptionViewModel.swift
│   │   └── SettingsViewModel.swift
│   ├── AppDelegate.swift
│   └── SceneDelegate.swift
├── Models/
│   ├── Recipe.swift
│   ├── Folder.swift
│   ├── User.swift
│   └── Ingredient.swift
├── Services/
│   ├── API/
│   │   ├── RecipeService.swift
│   │   └── AIIntegration.swift
│   ├── AuthService.swift
│   ├── PaymentService.swift
│   └── AnalyticsService.swift
├── Resources/
│   ├── Assets.xcassets
│   ├── Localization/
│   │   └── en.lproj
│   └── LaunchScreen.storyboard
├── Utils/
│   ├── Extensions/
│   │   └── String+Extensions.swift
│   ├── Constants.swift
│   └── Helpers.swift
├── Tests/
│   ├── UnitTests/
│   │   ├── RecipeTests.swift
│   │   ├── FolderTests.swift
│   │   └── UserTests.swift
│   └── UITests/
│       ├── RecipeSearchUITests.swift
│       └── FolderUITests.swift
├── Info.plist
└── Package.swift
```

### Explanation:

- App/Views: Contains all SwiftUI views for the app's UI
- App/ViewModels: Houses the logic that interfaces between the views and models (MVVM pattern)
- Models: Data structures representing core entities
- Services: Handles API calls, authentication, payments, and analytics
- Resources: Contains assets like images, localization files, and the launch screen
- Utils: General utilities, extensions, and constants used throughout the app
- Tests: Organized into unit tests and UI tests for thorough coverage

## Use Cases and User Flow

### Use Case 1: Searching for Recipes (with OpenAI API)

1. User navigates to the search screen
2. User enters a query, e.g., "Vegan Chocolate Cake"
3. App constructs a prompt incorporating the user's query
4. App sends a POST request to the OpenAI API endpoint with the prompt
5. OpenAI API processes the request and generates a recipe
6. App receives the response and checks for errors
7. App parses the JSON-formatted recipe into the Recipe model
8. App displays the recipe in RecipeDetailView
9. User can save, print, or share the recipe

### Use Case 2: Organizing Recipes into Folders

1. User selects the "Save" option on a recipe
2. App prompts the user to select an existing folder or create a new one
3. User makes a selection or creates a folder
4. FolderViewModel updates the user's folder data
5. Data is synced to the backend for persistence
6. User can view saved recipes in FolderListView and FolderDetailView

### Use Case 3: Unlocking Premium Features

1. User attempts to access a premium feature
2. App checks the user's subscription status via AuthService
3. If not subscribed, App displays SubscriptionView
4. User completes the subscription process using PaymentService
5. App grants access to premium features
6. AnalyticsService logs the subscription event

### Use Case 4: Printing or Sharing Recipes

1. User opens a recipe in RecipeDetailView
2. User selects "Print" or "Share" from options
3. App uses UIActivityViewController to present sharing options
4. User completes the print or share action

## Non-Functional Requirements

### Performance

- AI Response Time: Under 3 seconds for recipe generation
- UI Responsiveness: View transitions and animations should be smooth

### Security

- Data Protection: Use encryption for sensitive data
- Authentication: Secure login mechanisms and token handling
- API Keys: Store securely, not exposed in the app bundle

### Usability

- Intuitive Design: Follow Apple's Human Interface Guidelines
- Accessibility:
  - Support for VoiceOver
  - Dynamic Type for font resizing
  - Sufficient color contrast

### Reliability

- Crash-Free Sessions: Aim for 99.9% crash-free user sessions
- Error Handling: User-friendly error messages and recovery options

### Maintainability

- Code Organization: Modular codebase following MVVM architecture
- Documentation: Inline code comments and external documentation

### Scalability

- Backend Infrastructure: Capable of handling growth in user base
- Modular Architecture: Easy addition of new features or services

## Data Models

```swift
// Recipe.swift
struct Recipe: Identifiable, Codable {
    let id: UUID = UUID()
    let title: String
    let ingredients: [String]
    let instructions: [String]
    let imageUrl: URL?
    let isPremium: Bool
}

// Ingredient.swift (if needed for detailed ingredients)
struct Ingredient: Codable {
    let name: String
    let quantity: String
}

// Folder.swift
struct Folder: Identifiable, Codable {
    let id: UUID = UUID()
    var name: String
    var recipes: [Recipe]
}

// User.swift
struct User: Identifiable, Codable {
    let id: UUID = UUID()
    let email: String
    var isPremiumSubscriber: Bool
    var folders: [Folder]
}
```

## Prompt Engineering

### Example of an Effective Prompt:

```
You are an expert chef specializing in vegan cuisine. Generate a detailed recipe for "Vegan Chocolate Cake". The recipe should include:

- A list of ingredients with precise quantities
- Step-by-step cooking instructions
- Any necessary preparation or cooking tips

Format the response in JSON with the following structure:

{
  "title": "Recipe Title",
  "ingredients": ["Quantity and ingredient", "..."],
  "instructions": ["Step 1", "Step 2", "..."]
}
```

## Error Handling

- Network Errors:
  - Display a user-friendly message
  - Provide a retry option
- API Errors:
  - Log errors with AnalyticsService
  - If the AI service fails, present a fallback message

## Testing Guidelines

- Unit Tests:
  - Aim for coverage of at least 80% of the codebase
- UI Tests:
  - Test core user flows: searching, saving, subscribing
- Integration Tests:
  - Validate interactions with the AI API and backend services

## Code Style and Conventions

- Use camelCase for variable and method names
- Use UpperCamelCase for type names
- Include documentation comments for public interfaces

## CI/CD

- Code Reviews:
  - AI assistant should generate code with clear comments
- Build Automation:
  - Use GitHub Actions or similar for automated builds and tests
- Deployment:
  - Set up TestFlight for beta testing

## Premium Features

### Enhanced Recipe Generation

- Model Selection: Use gpt-4 for premium users if available
- Additional Preferences: Incorporate user preferences like dietary restrictions, cuisine types, or ingredient exclusions

### Example Premium Prompt:

```
You are a professional chef. Generate a gluten-free and dairy-free recipe for "Pancakes". Include substitutes for common allergens. Format the response in JSON with 'title', 'ingredients', and 'instructions' fields.
```

## Rate Limiting and Cost Management

- Caching: Implement caching for repeated queries to reduce API calls
- Usage Limits: Set usage limits per user, especially for free-tier users
- Monitoring: Regularly monitor API usage and costs through OpenAI's dashboard

## OpenAI Policy Compliance

- Disallowed Content: Implement filters to prevent the generation of disallowed content
- Attribution: Provide appropriate attribution if required
- Privacy: Do not send any personally identifiable information (PII) in API requests

## Next Steps

1. Implement the API integration using the provided examples
2. Test the functionality thoroughly with various user inputs
3. Optimize prompts based on testing to improve response quality
4. Monitor API usage and adjust parameters as needed